\subsection{Modelling Decentralised E-Commerce}
  The main aim of this research is to construct a model that closely follows the dynamics
  of a marketplace. Following the Universal Composability framework, we define $n$
  interactive Turing Machines (ITMs) that represent the players that take part in the
  marketplace game. Their description is $\Pi_{\mathrm{SAT}}$, the satisfaction protocol.
  These ITMs comprise the set $\mathcal{P}$. Furthermore, we define an ITM named
  Environment and represented by $\mathcal{E}$.

  The latter ITM is the first to start functioning. Initially, its responsibility is to
  allocate a utility function to each player, drawn from a distribution on legal utility
  functions that is common knowledge \cite{knowledge} to the players. We will elaborate on
  the nature of the utility functions later on. Additionally, $\mathcal{E}$ provides
  players with an initial ``endowment'' of assets and money. Contrary to the utility
  functions, these are not sent only to the players, but additionally to the
  $\mathcal{G}_{\mathrm{Assets}}$ and $\mathcal{G}_{\mathrm{Ledger}}$ global
  functionalities respectively. These two functionalities exist with the sole purpose of
  keeping track of physical and digital assets respectively. We will later provide further
  explanation as to why we introduce these global functionalities.

  After providing the utility functions and the endowments, the main part of the game
  begins. $\mathcal{E}$ can send a message to $\mathrm{Alice} \in \mathcal{P}$ that
  contains a desire $d$ to be satisfied. To satisfy this desire, Alice has to buy an asset
  that satisfies $d$ from some other player. The first and most important task Alice faces
  is who to trade with. For that purpose, she consults with the functionality
  $\mathcal{F}_{\mathrm{Trust}}$, which hopefully responds with a trustworthy vendor, say
  Bob. Then Alice asks Bob whether he is willing to satisfy her desire with a satisfying
  asset and, if so, at what price. Given that Bob offers a reasonable price, Alice
  instructs the functionality $\mathcal{F}_{\mathrm{Trade}}$ to pay Bob the designated
  price in exchange for the satisfying asset. The functionality pays Bob and crucially
  asks him if he wants to complete the exchange honestly or cheat. It then completes the
  trade as instructed by Bob by interacting with the two global functionalities
  appropriately and reports back to Alice the result. Finally Alice reports the result to
  $\mathcal{E}$ and $\mathcal{F}_{\mathrm{Trust}}$. The latter updates the trust
  properties connected to Bob depending on Alice's report. Just like Bob could cheat and
  not deliver the satisfying asset, Alice has the ability to misreport her experience with
  Bob.

  We will now go into further detail regarding the several parts of the construction.

  \subimport{./progress/ecommerce/}{assetsfunc.tex}
  \subimport{./progress/ecommerce/}{ledgerfunc.tex}
  \subimport{./progress/ecommerce/}{tradefunc.tex}
  \subimport{./progress/ecommerce/}{trustfunc.tex}
  \subimport{./progress/ecommerce/}{utilityfunc.tex}
  \subimport{./progress/ecommerce/}{satfunc.tex}
  \subimport{./progress/ecommerce/}{combination.tex}
  \subimport{./progress/ecommerce/}{results.tex}
